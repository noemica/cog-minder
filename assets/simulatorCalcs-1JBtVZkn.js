import{C as y}from"./ItemPopover-mPiD5eR1.js";import{i as A,aa as g,a2 as Q}from"./index-DEE0P6Bj.js";var Y=(e=>(e.Alien="Alien",e.Architect="Architect",e.Derelict="Derelict",e.Drone="Drone",e.Exiles="Exiles",e.Prototype="Prototype",e.Redacted="Redacted",e.Spoiler="Spoiler",e.OB10="0b10",e.Warlord="Warlord",e.Zhirov="Zhirov",e.Zionite="Zionite",e))(Y||{}),P=(e=>(e.Coring="Coring",e.Criticals="Criticals",e.Dismemberment="Dismemberment",e.Disruption="Disruption",e.Hacking="Hacking",e.Jamming="Jamming",e.Meltdown="Meltdown",e))(P||{});const $=10,w=95,b=100,ee=1e5,de=new Map([["Huge",30],["Large",10],["Medium",0],["Small",-10],["Tiny",-30]]),O=["Phase Wall","Vortex Field Projector","7V-RTL'S Ultimate Field","Force Field","Imp. Force Field","Adv. Force Field","Exp. Force Field","Shield Generator","Imp. Shield Generator","Adv. Shield Generator","Exp. Shield Generator","Stasis Bubble","Stasis Trap","Remote Shield","Imp. Remote Shield","Remote Force Field","Imp. Remote Force Field","Energy Mantle","Imp. Energy Mantle","AEGIS Remote Shield"],U=new Map([["Remote Shield",.75],["Stasis Trap",.75],["Phase Wall",.5],["Remote Force Field",.5],["Stasis Bubble",.5]]),B=[4,6,8,10],ce=[.2,.3,.4,.5],fe=60,ue=70,L=[5,6,8,12],ge=[2,3,4,6],me=new Map([["No Special",{bonus:0,recoilNegated:!1,tus:0}],["In Siege Mode",{bonus:15,recoilNegated:!0,tus:0}],["In High Siege Mode",{bonus:25,recoilNegated:!0,tus:0}],["In Martial Mode",{bonus:0,recoilNegated:!0,tus:0}],["Entering Siege Mode",{bonus:15,recoilNegated:!0,tus:700}],["Entering High Siege Mode",{bonus:25,recoilNegated:!0,tus:700}],["Entering Martial Mode",{bonus:0,recoilNegated:!0,tus:300}]]),ie={"Wide (10)":10,"Intermediate (30)":30,"Narrow (50)":50,"Fine (100)":100},V={1:200,2:300,3:325,4:350,5:375,6:400};function K(e){const i=e.botState;if(i.destroyedParts.length===0)return;const n=i.destroyedParts.splice(g(0,i.destroyedParts.length-1),1)[0];if(i.parts.push(n),i.armorAnalyzedCoverage+=n.armorAnalyzedCoverage,i.armorAnalyzedShieldedCoverage+=n.armorAnalyzedShieldedCoverage,i.armorAnalyzedSiegedCoverage+=n.armorAnalyzedSiegedCoverage,i.siegedCoverage+=n.siegedCoverage,i.totalCoverage+=n.coverage,n.resistances!==void 0)for(const r of Object.keys(n.resistances))r in i.resistances&&(i.resistances[r]+=n.resistances[r]);n.integrity=n.def.integrity,T(e)}function j(e,i,n,r,t,p,l,o,c,u,d,v,s,C){const h=[],D=Math.trunc(n/r);if(p)for(let f=0;f<r;f++)h.push({armorAnalyzed:!1,critical:void 0,coreBonus:0,damageType:d,disruptChance:0,forceCore:!1,guided:C,originalDamage:D,penetrate:!1,realDamage:0,salvage:v,spectrum:0});else for(let f=0;f<r;f++)h.push({armorAnalyzed:l,coreBonus:e.offensiveState.coreAnalyzerChance,critical:t,damageType:d,disruptChance:o,forceCore:!1,guided:C,originalDamage:D,penetrate:g(0,100)<=s,realDamage:0,salvage:v,spectrum:c});const M=I(i.defensiveState.damageReduction);let S=0,a=0,m=0;if(M!==void 0)a=M.reduction,S=M.ratio;else{const f=I(i.defensiveState.hardlightGenerator);f!==void 0&&(m=f.reduction)}for(const f of h){let x=0;if(M!==void 0&&M.remote?x=f.originalDamage-Math.trunc(f.originalDamage*(1-a))-m:x=Math.trunc(f.originalDamage*a)-m,a!=0){const z=x*S;i.energy>z?i.energy-=z:x=0}f.realDamage=f.originalDamage-x}i.salvage+=v;for(const f of h){if(f.realDamage===0)return;if(W(e,f.coreBonus,f.realDamage,f.damageType,f.critical,u,!1,f.forceCore,f.disruptChance,f.spectrum,f.armorAnalyzed,f.penetrate,f.guided),d==="Electromagnetic"){const x=I(i.defensiveState.corruptionIgnore),z=t===y.Corrupt&&!i.immunities.includes(P.Criticals);if(x===void 0||g(0,99)>=x.chance){const q=z?1.5:g(50,150)/100,X=f.originalDamage*q;_(e,X)}}}}function W(e,i,n,r,t,p,l,o,c,u,d,v,s){const{part:C,partIndex:h}=ne(e.botState,i,r,l,o,d);k(e,n,r,t,c,u,p,l,v,s,C,h)}function _(e,i){const n=e.botState;let r=I(n.defensiveState.corruptionMaximum);r!==void 0&&(i=Math.min(r.maximumCorruption,i));let t=I(n.defensiveState.corruptionPrevent);for(;i>0&&t!==void 0;){const p=Math.ceil(t.part.integrity/2);if(p<i)t.part.integrity-=i*=2,i=0;else{n.defensiveState.corruptionPrevent.shift();const l=n.parts.indexOf(t.part);R(e,!1,l,t.part,0,"Entropic","Integrity"),t=I(n.defensiveState.corruptionPrevent),i-=p}}n.corruption+=i}function k(e,i,n,r,t,p,l,o,c,u,d,v){const s=e.botState;function C(a){return a===y.Destroy||a===y.Smash}if(r!==void 0&&(s.immunities.includes(P.Criticals)||I(s.defensiveState.critImmunity)!==void 0)&&(r=void 0),r===y.Meltdown&&!s.immunities.includes(P.Meltdown)){s.coreIntegrity=0,s.heat=Math.max(s.heat,300);return}else if(r===y.Intensify)i*=2;else if(r===y.Impale)i*=2,e.tus+=100;else if(r===y.Detonate){let a;for(a=0;a<s.parts.length&&s.parts[a].def.slot!=="Power";a++);if(a<s.parts.length){const m=s.parts[a];if(R(e,!1,a,m,0,"Entropic","Integrity"),Z(e,m),a===v)return}}else((r===y.Sever||r===y.Sunder)&&s.immunities.includes(P.Dismemberment)||r===y.Phase&&(s.immunities.includes(P.Coring)||N(s,"Core")!==void 0))&&(r=void 0);if(d===void 0){const a=o?void 0:N(s,"Core");if((r===y.Destroy||r==y.Phase||r==y.Smash||r==y.Sunder||r==y.Sever)&&(s.immunities.includes(P.Coring)||a!==void 0)&&(r=void 0),a!=null){const m=Math.trunc(a.reduction*i);if(a.part.integrity-=m,a.part.integrity<=0){const f=s.parts.indexOf(a.part);R(e,!1,f,a.part,0,"Entropic","Integrity")}i=i-m}if(r===y.Destroy||r===y.Smash?s.coreIntegrity=0:s.coreIntegrity-=i,s.coreIntegrity===0)return;if(!s.immunities.includes(P.Disruption)&&g(0,99)<t/2&&(s.coreDisrupted=!0),r===y.Sever||r===y.Sunder){const m=r===y.Sunder?g(1,2):1;for(let f=0;f<m;f++){const{part:x,partIndex:z}=F(s,void 0);x===void 0||N(s,x.def.slot)!==void 0||x.def.size>1||(x.integrity-=Math.trunc(x.def.integrity*g(5,25)/100),R(e,!1,z,x,0,"Phasic","CriticalRemove"))}return}else if(r===y.Blast){const{part:m,partIndex:f}=F(s,void 0);if(m===void 0||N(s,m.def.slot)!==void 0)return;m.def.size===1?(k(e,i,"Phasic",void 0,0,0,!1,!1,!1,!1,m,f),m.integrity>0&&!s.immunities.includes(P.Dismemberment)&&R(e,!1,f,m,0,"Phasic","CriticalRemove")):k(e,i,"Phasic",void 0,0,0,!1,!1,!1,!1,m,f)}else if(r===y.Phase){const{part:m,partIndex:f}=F(s,void 0);k(e,i,"Phasic",void 0,0,0,!1,!1,!1,!1,m,f)}return}const h=d.def.type==="Protection"||o?void 0:N(s,d.def.slot);h!==void 0&&C(r)&&(r=void 0);const D=d.def.slot==="Power"&&g(0,99)<p;if((C(r)&&d.protection||s.sieged&&d.def.type==="Treads"&&d.def.siege!==void 0)&&(r=void 0,i=Math.trunc(1.2*i)),d.selfDamageReduction!==0?i=Math.trunc(i*d.selfDamageReduction):d.def.type==="Treads"&&d.def.siege!==void 0&&s.sieged?i=Math.trunc(i*(d.def.siege==="High Siege"?.5:.75)):d.def.type==="Leg"&&d.def.shield&&s.shielded&&(!c&&!u&&g(0,1)===1?i=0:i=Math.trunc(i*.5)),h!=null){const a=Math.trunc(h.reduction*i);if(h.part.integrity-=a,h.part.integrity<=0){const m=s.parts.indexOf(h.part);R(e,!1,m,h.part,0,"Entropic","Integrity")}i=i-a}const M=d.integrity<=i||C(r)||D;if(!M&&(r===y.Sever||r===y.Sunder)&&d.def.size===1&&h===void 0&&(M||R(e,!1,v,d,0,"Slashing","CriticalRemove")),M){const a=r===y.Smash?i:i-d.integrity;R(e,l,v,d,a,n,"Integrity")}else d.integrity-=i;const S=v;if(r===y.Blast){const{part:a,partIndex:m}=F(s,M?S:void 0);if(a===void 0||h!==void 0)return;a.def.size===1?(k(e,i,"Phasic",void 0,0,0,!1,!1,!1,!1,a,m),a.integrity>0&&!s.immunities.includes(P.Dismemberment)&&R(e,!1,m,a,0,"Phasic","CriticalRemove")):k(e,i,"Phasic",void 0,0,0,!1,!1,!1,!1,a,m)}else r===y.Phase&&k(e,i,"Phasic",void 0,0,0,!1,!1,!1,!1,void 0,-1);D&&Z(e,d)}function re(e){const i={};for(const r of Object.keys(e.resistances))i[r]=e.resistances[r];const n={armorAnalyzedCoverage:e.armorAnalyzedCoverage,armorAnalyzedShieldedCoverage:e.armorAnalyzedShieldedCoverage,armorAnalyzedSiegedCoverage:e.armorAnalyzedSiegedCoverage,behavior:e.behavior,coreCoverage:e.coreCoverage,coreDisrupted:e.coreDisrupted,coreIntegrity:e.coreIntegrity,corruption:e.corruption,def:e.def,defensiveState:void 0,destroyedParts:[],dormant:e.dormant,energy:e.energy,energyGen:e.energyGen,externalDamageReduction:e.externalDamageReduction,heat:0,immunities:e.immunities,initialCoreIntegrity:e.initialCoreIntegrity,mass:e.mass,maximumEnergy:e.maximumEnergy,parts:e.parts.map(r=>({armorAnalyzedShieldedCoverage:r.armorAnalyzedShieldedCoverage,armorAnalyzedSiegedCoverage:r.armorAnalyzedSiegedCoverage,armorAnalyzedCoverage:r.armorAnalyzedCoverage,coverage:r.coverage,def:r.def,energyUpkeep:r.energyUpkeep,integrity:r.integrity,initialIndex:r.initialIndex,protection:r.protection,selfDamageReduction:r.selfDamageReduction,shieldedCoverage:r.shieldedCoverage,siegedCoverage:r.siegedCoverage})),partRegen:e.partRegen,coreRegen:e.coreRegen,resistances:i,running:e.running,runningEvasion:e.runningEvasion,runningMomentum:e.runningMomentum,salvage:e.salvage,shielded:e.shielded,shieldedCoverage:e.shieldedCoverage,sieged:e.sieged,siegedCoverage:e.siegedCoverage,superfortressRegen:e.superfortressRegen,support:e.support,tusToShield:e.tusToShield,tusToSiege:e.tusToSiege,totalCoverage:e.totalCoverage};return n.defensiveState=J(n.parts,n.externalDamageReduction,e.dormant),n}function Z(e,i){if(i.def.slot!=="Power")return;const n=i.def;if(n.explosionDamageMax>0&&n.explosionType!==void 0){const r=g(n.explosionDamageMin,n.explosionDamageMax),t=g(n.minChunks??0,n.maxChunks??0),p=Math.trunc(r/t);e.botState.salvage+=n.explosionSalvage;for(let l=0;l<t;l++)W(e,0,p,n.explosionType,void 0,!0,!1,!1,n.explosionDisruption,se(n.explosionSpectrum),!1,!1,!1)}}function H(e,i,n){return n in e.resistances?Math.trunc(i*(1-e.resistances[n]/100)):i}function J(e,i,n){const r={antimissile:[],avoid:[],corruptionIgnore:[],corruptionMaximum:[],corruptionPrevent:[],corruptionReduce:[],critImmunity:[],damageReduction:[],hardlightGenerator:[],rangedAvoid:[],shieldings:{Core:[],"N/A":[],Power:[],Propulsion:[],Utility:[],Weapon:[]}};for(const t of e)if(A(t.def,!n,"AntimissileChance"))r.antimissile.push({chance:t.def.specialProperty.trait.chance,part:t});else if(A(t.def,!n,"ReactionControlSystem"))r.avoid.push({chance:t.def.specialProperty.trait.chance,part:t});else if(A(t.def,!n,"CorruptionIgnore"))r.corruptionIgnore.push({chance:t.def.specialProperty.trait.chance,part:t});else if(A(t.def,!n,"CorruptionMaximum"))r.corruptionMaximum.push({part:t,maximumCorruption:t.def.specialProperty.trait.amount});else if(A(t.def,!n,"CorruptionPrevent"))r.corruptionPrevent.push({part:t});else if(A(t.def,!n,"CorruptionReduce"))r.corruptionReduce.push({amount:t.def.specialProperty.trait.amount,part:t});else if(A(t.def,!n,"CriticalImmunity"))r.critImmunity.push({part:t});else if(A(t.def,!n,"DamageReduction"))r.damageReduction.push({ratio:t.def.specialProperty.trait.ratio,reduction:t.def.specialProperty.trait.multiplier,remote:t.def.specialProperty.trait.remote,part:t});else if(A(t.def,!n,"DamageResists"))t.resistances=t.def.specialProperty.trait.resists;else if(A(t.def,!n,"HardlightGenerator"))r.hardlightGenerator.push({reduction:t.def.specialProperty.trait.amount,part:t});else if(A(t.def,!n,"RangedAvoid"))r.rangedAvoid.push({avoid:t.def.specialProperty.trait.avoid,part:t});else if(A(t.def,!n,"SelfReduction"))t.selfDamageReduction=t.def.specialProperty.trait.shielding;else if(A(t.def,!n,"Shielding")){const p=t.def.specialProperty.trait;r.shieldings[p.slot].push({reduction:p.shielding,part:t})}if(U.has(i)){const t=U.get(i)||1,p=i.includes("Remote");if(r.damageReduction.length===0)r.damageReduction.push({ratio:0,reduction:t,remote:p,part:{armorAnalyzedShieldedCoverage:0,armorAnalyzedSiegedCoverage:0,armorAnalyzedCoverage:0,coverage:0,def:void 0,energyUpkeep:0,integrity:1,initialIndex:0,protection:!1,selfDamageReduction:0,shieldedCoverage:0,siegedCoverage:0}});else{const l=O.indexOf(r.damageReduction[0].part.def.name);O.indexOf(i)<l?r.damageReduction.unshift({ratio:0,reduction:t,remote:p,part:{armorAnalyzedCoverage:0,armorAnalyzedShieldedCoverage:0,armorAnalyzedSiegedCoverage:0,coverage:0,def:void 0,energyUpkeep:0,integrity:1,initialIndex:0,protection:!1,selfDamageReduction:0,shieldedCoverage:0,siegedCoverage:0}}):r.damageReduction.push({ratio:0,remote:p,reduction:t,part:{armorAnalyzedCoverage:0,armorAnalyzedShieldedCoverage:0,armorAnalyzedSiegedCoverage:0,coverage:0,def:void 0,energyUpkeep:0,initialIndex:0,integrity:1,protection:!1,selfDamageReduction:0,shieldedCoverage:0,siegedCoverage:0}})}}return r}function R(e,i,n,r,t,p,l){const o=e.botState;if(o.parts.splice(n,1),o.armorAnalyzedCoverage-=r.armorAnalyzedCoverage,o.armorAnalyzedShieldedCoverage-=r.armorAnalyzedShieldedCoverage,o.armorAnalyzedSiegedCoverage-=r.armorAnalyzedSiegedCoverage,o.siegedCoverage-=r.siegedCoverage,o.shieldedCoverage-=r.shieldedCoverage,o.totalCoverage-=r.coverage,o.mass-=r.def.mass||0,r.def.type===o.def.propulsionType?o.support-=r.def.mass||0:A(r.def,!0,"MassSupport")&&(o.support-=r.def.specialProperty.trait.support),r.resistances!==void 0)for(const c of Object.keys(r.resistances))c in o.resistances&&(o.resistances[c]-=r.resistances[c]);if(t>0&&!r.protection&&i&&W(e,0,t,p,void 0,!0,!0,!1,0,0,!1,!1,!1),p==="Impact"){let c=g(50,150);c=H(o,c,"Electromagnetic"),_(e,c)}l==="CriticalRemove"&&r.integrity>0&&r.def.type!=="Processor"&&r.def.type!=="Hackware"&&(e.lootState.items[r.initialIndex].numDrops+=1,e.lootState.items[r.initialIndex].totalCritRemoves+=1,e.lootState.items[r.initialIndex].totalIntegrity+=r.integrity,e.lootState.items[r.initialIndex].integrityDrops.push(r.integrity)),r.integrity=0,T(e),r.def.slot==="Power"&&(o.energyGen-=r.def.energyGeneration||0,o.maximumEnergy-=r.def.energyStorage||0,o.energy=Math.min(o.energy,o.maximumEnergy)),o.destroyedParts.push(r)}function I(e){let i;for(;e.length>0;)if(e[0].part.integrity>0){i=e[0];break}else e.shift();return i}function ne(e,i,n,r,t,p){let l,o=-1;if(t)return{part:l,partIndex:o};if(n==="Impact"){let c=g(0,e.parts.map(u=>u.def.size).reduce(Q,0));for(let u=0;u<e.parts.length;u++){if(c<e.parts[u].def.size){o=u;break}c-=e.parts[u].def.size}o>=0&&(l=e.parts[o])}else if(r){const c=e.parts.filter(u=>u.protection&&u.coverage>0);if(c.length>0){let u=g(0,c.reduce((d,v)=>d+v.coverage,0));for(let d=0;d<c.length;d++)if(u-=c[d].coverage,u<0){l=c[d];break}o=e.parts.indexOf(l)}}if(l===void 0&&n!=="Impact"){let c;if(p?e.sieged?c=e.armorAnalyzedSiegedCoverage:e.shielded?c=e.armorAnalyzedShieldedCoverage:c=e.armorAnalyzedCoverage:e.sieged?c=e.siegedCoverage:e.shielded?c=e.shieldedCoverage:c=e.totalCoverage,n=="Piercing"&&(i+=8),i>0){c-=e.coreCoverage;const d=Math.min(e.coreCoverage/e.totalCoverage+i/100,.999),v=e.totalCoverage*d;c+=v}let u=g(0,c-1);for(o=0;o<e.parts.length;o++)if(p?e.sieged?u-=e.parts[o].armorAnalyzedSiegedCoverage:e.shielded?u-=e.parts[o].armorAnalyzedShieldedCoverage:u-=e.parts[o].armorAnalyzedCoverage:e.sieged?u-=e.parts[o].siegedCoverage:e.shielded?u-=e.parts[o].shieldedCoverage:u-=e.parts[o].coverage,u<0){l=e.parts[o];break}}return{part:l,partIndex:o}}function F(e,i){let n=g(0,e.parts.length-1-(i===void 0?0:1));return i!==void 0&&i>0&&n>=i&&(n+=1),n>=e.parts.length?{part:void 0,partIndex:-1}:{part:e.parts[n],partIndex:n}}function oe(e,i){let n=0;return e.recoil!==void 0&&(n+=e.recoil,n-=i),Math.max(n,0)}function pe(e,i){let n;if(e.length===0)return 0;e.length in V?n=V[e.length]:n=400;for(const r of e)n+=r.delay??0;return n*=i,Math.trunc(Math.max(25,n))}function N(e,i){return I(e.defensiveState.shieldings[i])}function E(e){let i=e.corruption;for(const n of e.defensiveState.corruptionReduce)n.part.integrity>=0&&(i-=n.amount);return i}const te={Kill:{volleyEndCondition:function(e){return e.coreIntegrity<=0||E(e)>=100},projectileEndCondition:function(e){return e.coreIntegrity<=0}},"Kill or Core Disrupt":{projectileEndCondition:function(e){return e.coreIntegrity<=0},volleyEndCondition:function(e){return e.coreIntegrity<=0||E(e)>=100||e.coreDisrupted}},"Kill or No Power":{projectileEndCondition:function(e){return e.coreIntegrity<=0},volleyEndCondition:function(e){return e.coreIntegrity<=0||E(e)>=100||e.parts.every(i=>i.def.slot!="Power")}},"Kill or No Weapons":{projectileEndCondition:function(e){return e.coreIntegrity<=0},volleyEndCondition:function(e){return e.coreIntegrity<=0||E(e)>=100||e.parts.every(i=>i.def.slot!="Weapon")}},"Kill or No TNC":{projectileEndCondition:function(e){return e.coreIntegrity<=0},volleyEndCondition:function(e){return e.coreIntegrity<=0||E(e)>=100||e.parts.every(i=>i.def.name!="Transport Network Coupler")}},Tele:{projectileEndCondition:function(e){return e.coreIntegrity<=0},volleyEndCondition:function(e){return e.coreIntegrity<=e.initialCoreIntegrity*.8||e.parts.filter(i=>i.def.slot==="Weapon").length===1||e.parts.filter(i=>i.def.slot==="Propulsion").length===1}}};function ve(e){const i=re(e.initialBotState);e.botState=i;const n=e.offensiveState;let r=0,t=!1,p=!1,l=Number.MAX_SAFE_INTEGER,o=0;e.tus=0,e.actionNum=0,T(e);const c=te[e.endCondition];n.sneakAttack=n.sneakAttackStrategy==="All"||n.sneakAttackStrategy==="First Only",n.momentum.current=n.momentum.bonus+n.momentum.initial;let u=!1;for(;!u;){const v=Math.trunc(o/100),s=Math.trunc(e.tus/100),C=s-v,h=i.coreRegen*C;i.coreIntegrity=Math.min(i.initialCoreIntegrity,i.coreIntegrity+h);const D=i.partRegen*C;for(const a of i.parts)a.integrity=Math.min(a.integrity+D,a.def.integrity);if(i.partRegen>0){const a=[...Array(C)].map((m,f)=>f+v).filter(m=>m%10===0).length;for(let m=0;m<a;m++)K(e)}i.superfortressRegen&&s<=i.superfortressRegen.nextRegenAttempt&&(K(e),i.superfortressRegen.nextRegenAttempt+=g(5,25)),s>=l&&!p?(i.dormant=!1,i.defensiveState=J(i.parts,i.externalDamageReduction,i.dormant),p=!0):!t&&i.behavior==="Unpowered 10 Turns"&&i.coreIntegrity!=i.initialCoreIntegrity&&(l=s+10,t=!0),i.energy+=i.energyGen;for(const a of i.parts)i.energy-=a.energyUpkeep;i.energy=Math.max(0,Math.min(i.energy,i.maximumEnergy)),r+=1;let M=n.volleyTime;if(n.melee){u=G(e,e.weapons[0],c.projectileEndCondition),e.actionNum+=1,e.actionNum<=2&&T(e);for(let a=1;a<e.weapons.length&&!u;a++)g(0,99)<n.followupChances[a-1]&&(u=G(e,e.weapons[a],c.projectileEndCondition),M+=.5*e.weapons[a].delay);M*=n.volleyTimeModifier,r===1&&(n.sneakAttackStrategy==="First Only"&&(n.sneakAttack=!1),n.momentum.current=n.momentum.bonus)}else{let a=!0;for(const m of e.weapons){if(u=G(e,m,c.projectileEndCondition),u)break;a&&(a=!1,e.actionNum+=1,e.actionNum<=2&&T(e))}}if(r>=ee)return!1;n.ramming&&(M=Math.max(100,n.speed)),o=e.tus,e.tus+=M;let S=!1;!n.melee&&o<n.specialBonus.tus&&e.tus>=n.specialBonus.tus&&(S=!0),o<i.tusToShield&&e.tus>=i.tusToShield&&i.behavior==="Shield/Fight"&&i.parts.find(a=>a.def.type==="Leg"&&a.def.shield)!==void 0&&(i.shielded=!0),o<i.tusToSiege&&e.tus>=i.tusToSiege&&i.behavior==="Siege/Fight"&&i.parts.find(a=>a.def.type==="Treads"&&a.def.siege!==void 0)!==void 0&&(i.sieged=!0,S=!0),i.behavior==="Run When Hit"&&i.runningMomentum<3&&(i.running=!0,i.runningMomentum=Math.min(Math.trunc(e.tus/i.def.speed),3)),S&&T(e),u=c.volleyEndCondition(i)}r in e.killVolleys?e.killVolleys[r]+=1:e.killVolleys[r]=1,e.tus in e.killTus?e.killTus[e.tus]+=1:e.killTus[e.tus]=1;for(const v of i.parts)if(v.integrity>0){const s=e.lootState.items[v.initialIndex];let C=g(0,99)<v.integrity/v.def.integrity*100/2+i.salvage;const h=E(i);C&&h>0&&g(0,99)<h-v.def.integrity&&(s.totalFried+=1,C=!1),C&&i.heat>0&&g(0,99)<(i.heat-v.def.integrity)/4&&(s.totalMelted+=1,C=!1),C&&(s.totalIntegrity+=v.integrity,s.integrityDrops.push(v.integrity),s.numDrops+=1,g(0,99)<h&&(s.totalCorruptionPercent+=g(1,Math.min(10*h/100,15))))}e.lootState.numKills+=1;let d=g(i.def.salvageLow,i.def.salvageHigh);return d+=i.salvage,d=Math.max(0,d),d=Math.min(d,i.def.salvageHigh),e.lootState.matterDrop+=d,!0}function G(e,i,n){const r=e.botState,t=e.offensiveState;if(t.ramming){const p=100/e.offensiveState.speed*100;let l=((10+i.def.mass)/5+1)*(p/100)*Math.max(e.offensiveState.momentum.current,1);l=Math.min(100,l);let o=g(0,l);return o=H(r,o,"Impact"),o>0&&j(e,r,o,1,void 0,!1,!1,0,0,!0,"Impact",3,0,i.def.waypoints!==void 0),n(r)}if(!t.melee&&t.corruption>0&&g(0,1e3)<t.corruption*2)return!1;for(let p=0;p<i.numProjectiles;p++){let l=t.melee&&t.sneakAttack||g(0,99)<i.accuracy;if(l&&i.isMissile){const o=I(r.defensiveState.antimissile);if(o!=null){const c=o.chance,u=Math.min(4,t.distance);for(let d=0;d<u;d++)if(g(0,99)<c){l=!1;break}}}if(l){if(i.def.type==="Ballistic Cannon"&&(i.def.salvage??0)<-2&&(e.lootState.matterBlasted+=Math.trunc(g(0,-i.def.salvage))),i.damageType!=null){let o=g(i.damageMin,i.damageMax);if(i.overloaded&&(o=Math.trunc(o*2)),t.melee&&t.momentum.current>0){const v=100/t.speed*100;let s=t.momentum.current*v/1200*40;s=Math.trunc(s),s=Math.max(1,s),s=Math.min(40,s),i.damageType==="Piercing"&&(s*=2),s=s/100+1,o=Math.trunc(s*o)}(t.melee&&t.sneakAttack||r.dormant)&&(o*=2),t.analysis&&(o=Math.trunc(1.1*o)),i.accelerated&&(o=Math.trunc(t.chargerBonus*o)),o=H(r,o,i.damageType);const c=g(0,99)<t.armorAnalyzerChance,u=g(0,99)<i.criticalChance;let d=0;if(i.def.penetrationChances!==void 0&&i.def.penetrationChances.length>0&&(d=Math.max(Math.min(i.def.penetrationChances[0],100),0)),o>0){if(j(e,r,o,1,u?i.criticalType:void 0,!1,c,i.disruption,i.spectrum,i.overflow,i.damageType,i.salvage,d,i.guided),i.def.name==="Core Stripper"&&r.coreIntegrity>0&&!r.immunities.includes(P.Dismemberment)&&g(0,99)<33)for(let v=0;v<r.parts.length;v++){const s=r.parts[0];s.integrity*=g(25,75)/100,R(e,!1,0,s,0,"Entropic","CriticalRemove"),r.coreIntegrity=0}if(n(r))return!0}}if(i.explosionType!=null){let o=g(i.explosionMin,i.explosionMax);o=H(r,o,i.explosionType);const c=g(i.explosionChunksMin,i.explosionChunksMax);if(o>0&&(j(e,r,o,c,void 0,!0,!1,i.explosionDisruption,0,!0,i.explosionType,i.salvage,0,i.guided),n(r)))return!0}}}return!1}function se(e){return e===void 0?0:ie[e]}function T(e){const i=e.offensiveState,n=e.botState;let r=0;(n.def.propulsionType==="Hover Unit"||n.def.propulsionType==="Flight Unit")&&n.support>0&&n.mass<=n.support&&(r-=10);const t=I(n.defensiveState.avoid);t!=null&&n.support>0&&(r-=t.chance),i.analysis&&(r+=5);let p=!1;if(i.melee){for(let o=0;o<L.length;o++)r+=i.meleeAnalysis[o]*L[o];let l=0;for(let o=i.forceBoosters.length-1;o>=0;o--)i.forceBoosters[o]==2?(r-=1.5*B[o],l+=2):i.forceBoosters[o]==1&&(r-=B[o]*l==0?1:.5,l+=1)}else{r+=i.distance<6?(6-i.distance)*3:0;const l=i.specialBonus;e.tus>=l.tus&&(r+=l.bonus,p=l.recoilNegated);const o=I(n.defensiveState.rangedAvoid);o!=null&&(r-=o.avoid)}e.actionNum===0?r+=e.offensiveState.action1Accuracy:e.actionNum===1?r+=e.offensiveState.action2Accuracy:r+=10,n.sieged&&(r+=10),n.running&&(n.parts.find(l=>l.def.type==="Leg")!==void 0&&(r-=5*n.runningMomentum),r-=n.runningEvasion);for(const l of e.weapons){if(l.guided){l.accuracy=100;return}let o=l.baseAccuracy+r;!i.melee&&!p&&(o-=i.recoil-oe(l.def,i.recoilReduction));const c=i.melee?b:w;l.accuracy=Math.min(c,Math.max(o,$))}}export{Y as B,J as a,oe as b,de as c,se as d,fe as e,ve as f,pe as g,ee as h,ue as i,ce as j,P as k,ge as m,me as s,V as v};
